# Lucene 내용 정리 

- 루씬 자체는 검색 어플리케이션은 아니다. 색인과 검색 기능을 제공해줄 뿐. 

## 검색 어플리케이션 구조 

![](./images/search%20application.png)

## (1) 색인 과정

- 색인: 문서를 빠르게 찾을 수 있도록 문서를 검색하기 좋은 형태로 변형하는 것. 

### 색인에서 중요한 것. 

- 가능하다면 가장 최근의 색인한 걸 파악해서 변경된 부분만 색인하도록 하는 것. (색인 대상의 개수를 줄이기 위해서.)

### 루씬 문서를 생성 

- 검색할 대상의 원본 문서를 얻었다렴 루씬 문서로 변환하는 과정이 필요하다.
- 예를 들어서 책에 대한 원본 문서를 루씬 문서로 변형한다면 각 필드가 붙은 문서가 될 것. 책에 대한 저자, 책 내용 (본문), 책 내용 (요약), 링크 등이 필드로 붙는다.
- 필요하다면 색인 과정에서 중요 필드를 지정할 수 있다. (스코어링 기반의 문서 검색을 할 떄 쓰겠지.)

### 문서 텍스트 분석 (Text Analysis)

- 문서 필드안에 텍스트들을 담았다면 텍스트를 분석해서 색인으로 만들어야 한다. (Inverted Index 를 만드는 과정)
- 텍스트 분석기를 통해서 텍스트 -> Token -> Filtering -> Term (in Inverted Index) 를 만든다. 

### 색인에 문서 추가. 

- 색인이 모두 끝나고 나면 문서가 색인에 추가된다. 

### 색인 관련 핵심 클래스 

- 처리되는 과정을 보면 Document (with Fields) -> Analyzer -> IndexWriter -> Directory 가 순으로 처리됨.
- IndexWriter
  - 색인을 새로 생성하거나 기존 색인을 열고 문서를 추가하거나, 삭제하는 역할을 담당한다. 
  - 색인을 변경하는 기능을 담당한다고 보면 된다. 색인을 검색하는 기능은 없다.
  - IndexWriter 는 색인을 저장하는 공간을 필요로 하며 색인을 저장하는 공간은 Directory 클래스로 표현된다.
  - Analyzer 를 통해 분석된 결과가 있어야 작업을 할 수 있다.
- Directory
  - 루씬의 색인을 저장하는 공간을 나타낸다. 
  - 추상클래스다. 즉 상속해서 써야한다.
- Analyzer 
  - 본문의 내용이나 제목 등 텍스트를 색인하기 전에 분석기 (Analyzer) 를 통해서 텍스트를 Term 으로 만들어야 한다. 
  - 이 과정에서 불필요한 단어는 제거할 수도 있다. 대소문자를 구별안하게 할 수도 있다. 
  - Analyzer 는 추상 클래스고 루씬안에는 다양한 Analyzer 가 있다.
- Document 
  - Fields 의 집합. 가상의 문서라고 생각해도 된다. 
  - 검색 결과를 담당하는 클래스다. 
  - 문서 내부의 필드는 실제 문서의 내용이나 메타 정보가 들어갈 수 있다. 
  - 루씬에서 색인 할려면 원본 문서에서 뽑아낸 텍스트를 Fields 클래스로 담아서 Analyzer 에게 전달해주면 된다.
  - 문서의 메타 정보는 본문과 서로 다른 필드로 함께 담아서 색인이 가능하다. 
- Fields 
  - 모든 문서는 필드가 있다. 필드는 각자 이름과 값이 있다.
  - 필드마다 각각의 색인 방식이 다를 수 있다.
  - 루씬에서 필드의 이름은 중복될 수 없다.


## (2) 검색 과정

- 검색이란 색인에 들어있는 토큰 (Term 이라고도 부르지 않나.) 을 기준으로 토큰이 들어있는 문서를 찾아내는 것을 말한다.
- 검색의 품질은 흔히 정확도 (Precision) 과 재현율 (recall) 로 결졍난다. 
  - 이걸 측정하는 방법은 부록 C 에 있다고 한다. 
- 여러가지 검색을 지원해야한다.
  - 단일 검색, 다중 검색, 문장 질의, 와일드 카드 질의, 퍼지 (fuzzy) 질의 등.
- 그리고 결과 문서의 순위를 정하거나 정렬하는 기능 그리고 사용자가 손쉽게 검색하는 방법등도 중요하다.

### 검색 사용자 인터페이스

- 너무 많은 정보를 보여주지 않도록, 너무 작은 글씨를 보여주지 않도록.

### 검색 질의 생성 

- 사용자가 검색 결과를 보기 위해서 버튼 같은 걸 눌렀다면 사용자의 쿼리를 바탕으로 검색 엔진에서 사용할 Query 객체를 만들어야한다. 
- 루씬에서는 이를 도와주는 `QuertParser` 라는 객체가 있다. 
- 질의에는 Boolean 검색, 구문 질의 ("" 로 구별), 와일드 카드 질의 같은 것들이 가능하다.
- 질의마다 검색할 수 있는 제약 사항을 둘려면 질의에 Filter 기능을 적용해서 격리하면 된다. 
  - 전자 상거래 어플리케이션의 경우에 재고가 없는 상품의 경우에는 Filter 기능을 둬서 검색 결과에서 뺴도록.
  - 그리고 이익률이 높은 제품의 경우 먼저 나오도록 가중치를 높게.
- 검색엔진에서 결과를 가져오거나, 필터를 적용하는 방법, 정렬하는 방법은 lucene in action 6장에서 다룬다고 하는듯. 

### 이론적인 검색 모델 

- 순수 불리언 모델 
  - 스코어링 기반의 검색이 아님.
  - 질의가 해당 문서에 일치하는지, 아닌지가 중요함.
- 백터 공간 모델
  - 질의와 문서 모두 벡터로 표현. (각 텀이 하나의 차원)
  - 그래서 질의와 문서가 얼마나 가깝냐로 문서 결과를 내보냄. (스코어링 계산)
- 확률 모델 
  - 질의가 문서에 매칭되는지를 확률로 측정함.

### 검색 관련 핵심 클래스

- IndexSearcher
  - 검색의 기능을 담당한다.
  - 색인을 읽기 전용으로 열어서 사용한다. 
  - 따라서 색인이 저장되어 있는 Directory 인스턴스를 생성자로 지정해줘야한다.
- Term
  - 검색 과정을 구현하는 가장 기본적인 단위. 
  - Fields 클래스 처럼 Term 클래스도 필드 이름과 해덩 필드에 속한 특정 단어의 쌍으로 구성된다.
  - (사실 색인 과정에서도 참여하지만 루씬 내부에서 자동적으로 생성하기 때문에 크게 생각안해도됨.)
  - 댜만 검색 시점에는 Term 객체를 통해서 TermQuery 객체를 만들 수 있다.
```java
Query q = new TermQuery(new Term("contents", "lucene")) // 필드가 contents 고 값이 lucene 인 term 을 생성해 질의 할려는 것. 
TopDocs hits = searcher.search(q, 10); // query 를 통해 검색. 상위 10개의 문서를 가져온다. 
 ```

- Query
  - 루씬에서는 Query 클래스를 상속받는 다양한 종류의 질의 클래스가 있다. 
  - 이 중 가장 간단한 질의는 TermQuery 이다.
  - 다양한 BooleanQuery, PhraseQuery, PrefixQuery, PhrasePrefixQuery, TermRangeQuery, NumericRangeQuery, FilteredQuery, SpanQuery 가 있다. 
- TermQuery
  - 루씬에서 가장 간단한 질의는 TermQuery 가 있다. 
- TopDocs
  - TopDocs 클래스는 최상위 N 개의 문서에 대한 결과를 가져오도록 하는 클래스다.
